<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>webpack</title>
</head>

<body>
    <div class="article-img-box">
        <img class="article-img" src="http://sparklv.cn/img/test.jpg" alt="美女">
    </div>
    <div class="article-box">
        <h1 id="webpack20">webpack 2.0</h1>

        <hr />

        <h2 id="">安装</h2>

        <pre><code class="node language-node">npm install --save-dev webpack
        </code></pre>

        <p>webpack.config.js</p>

        <pre><code class="javascript language-javascript">const path = require('path')
        
        module.exports = {
            entry:'./src/index.js',
            output:{
                filename:'bundle.js',
                path:path.resolve(__dirname,'dist')
            }
        }
        </code></pre>

        <p>package.json</p>

        <pre><code class="javascript language-javascript">"scripts":{
            "build":"webpack"
        }
        </code></pre>

        <h2 id="-1">核心概念</h2>

        <h3 id="entry">entry</h3>

        <p>入口起点告诉webpack从哪里开始，并根据依赖关系图确定需要打包的内容，可以将应用程序的入口起点认为是根上下文或app第一个启动文件</p>

        <ul>
            <li>单个入口语法</li>
        </ul>

        <pre><code class="javascript language-javascript">entry:'./path/to/file.js'
        </code></pre>

        <ul>
            <li>对象语法</li>
        </ul>

        <pre><code class="javascript language-javascript">entry:{
            app:'./src/app.js',
            vendors:'./src/vendors.js'
        }
        </code></pre>

        <ul>
            <li>多页面应用程序</li>
        </ul>

        <pre><code class="javascript language-javascript">new htmlWebpackPlugin({
            filename:"index.html",
            template:__dirname+"/index.html",
            inject:"head",
            title:'webpack is awesome',
            chunks:['main']
        })
        利用chunks分配不同js到不同html
        </code></pre>

        <h3 id="output">output</h3>

        <p>将所有资源归拢在一起后，要告诉webpack在哪里打包应用程序。即使可以存在多个入口起点，但是只指定一个输出配置</p>

        <ul>
            <li>filename 用于输出文件的文件名</li>

            <li>path 目标输出目录的绝对路径</li>
        </ul>

        <p>如果配置创建了多个单独的chunk，则应该使用占位符来确保每个文件具有唯一的名字。 占位符可以是[name] [chunkhash] [hash] 使用publicPath可以指定http路径
        </p>

        <h3 id="loader">loader</h3>

        <p>webpack把每个文件都作为模块处理，webpack自身只理解javascript</p>

        <p>loader可以将文件从不同的语言转换为javascript(为此，首先安装相对应的loader)</p>

        <h4 id="loader-1">使用loader有三种使用方式</h4>

        <ul>
            <li>配置：在webpack.config.js文件中指定loader。</li>
        </ul>

        <pre><code class="javascript language-javascript">module: {
            rules: [
                {
                test: /\.css$/,
                use: [
                    { loader: 'style-loader' },
                    {
                    loader: 'css-loader',
                    options: {
                    modules: true
                        }
                    }
                ]
            }
        ]
        }
        </code></pre>

        <ul>
            <li>内联：可以在import语句或任何等效于import的方式中指定loader。使用！将资源中的loader分开</li>

            <li>CLI：例如</li>
        </ul>

        <p>webpack --module-bind jade-loader --module-bind 'css=style-loader!css-loader'</p>

        <h3 id="fileloaderindexhtmlimgsrc">对于使用file-loader时，加载图片，在打包编译之后，index.html中img的src地址并没有替换的情况</h3>

        <pre><code class="html language-html">使用以下写法
        &lt;img src="$ {require('./assets/erha.jpg')}"&gt;
        </code></pre>

        <h3 id="plugins">plugins</h3>

        <p>plugins常用于在打包模块的compilation和chunk生命周期执行操作和自定义功能</p>

        <h4 id="-2">模块热替换</h4>

        <pre><code class="javascript language-javascript">npm install webpack-dev-server --save-dev
        webpack.config.js
        
        const webpack = require('webpack')  
        devServer:{
            contentBase:__dirname+'/dist',
            hot:true
        }
        plugins:[
            new webpack.HotModuleReplacementPlugin()
        ]
        
        package.json
        
        script:{
            "dev":"webpack-dev-server --open"
        }
        </code></pre>

        <h4 id="-3">精简输出</h4>

        <pre><code class="node language-node">npm install --save uglifyjs-webpack-plugin
        </code></pre>

        <p>webpack.config.js</p>

        <pre><code class="javascript language-javascript">const UglifyJsPlugin = require('uglifyjs-webpack-plugin')
        
        plugins:[
            new UglifyJsPlugin()
        ]
        </code></pre>

        <h2 id="-4">生产环境构建</h2>

        <h3 id="webpackmerge">使用webpack-merge提取出共同的配置</h3>

        <pre><code class="node language-node">npm install --save webpack-merge
        </code></pre>

        <p>webpack.prod.js</p>

        <pre><code class="javascript language-javascript">const merge = require('webpack-merge')
        const common = require('./webpack.common.js')
        
        module.export = merge(common,{
            plugins:[
                new UglifyJSPlugin()
            ]
        })
        </code></pre>

        <p>webpack.dev.js</p>

        <pre><code class="javascript language-javascript">const merge = require('webpack-merge')
        const common = require('./webpack.common.js')
        
        module.export = merge(common,{
            devtool:'inline-source-map',
            devServer:{
                contentBase:'./dist',
                hot:'true'
            }
        })
        </code></pre>

        <p>package.json</p>

        <pre><code class="json language-json">"start":"webpack-dev-server --open --config webpack.dev.js"
        "build":"webpack --config webpack.prod.js"
        </code></pre>

        <h3 id="-5">指定环境</h3>

        <pre><code class="javascript language-javascript">plugins:[
            new webpack.DefinePlugin({
                'process.env.NODE_ENV':JSON.stringify('production')//可以自定义变量
            })
        ]
        </code></pre>

        <h2 id="-6">代码分离</h2>

        <h3 id="-7">入口起点</h3>

        <h4 id="-8">可以设置多个入口起点</h4>

        <ul>
            <li>但是如果入口chunks之间包含重复的模块，哪些重复的模块都会被引入到各个bundle中</li>
        </ul>

        <h3 id="-9">防止重复</h3>

        <p>CommonsChunkPlugin插件可以将公共的依赖模块提取到已有入口chunk中，或者提取到一个新生成的chunk</p>

        <p>webpack.config.js</p>

        <pre><code class="javascript language-javascript">new webpack.optimize.CommonsChunkPlugin({
            name:'common'
        })
        </code></pre>

        <h3 id="-10">动态导入</h3>

        <p>webpack.config.js</p>

        <pre><code class="javascript language-javascript">output:{
            chunkFilename:'[name].bundle.js'
        }
        </code></pre>

        <p>index.js</p>

        <pre><code class="javascript language-javascript">import(/*webapckChunkName: "lodash"*/'lodash').then(_=&gt;{
        }).catch(error=&gt;console.log(error))
        </code></pre>

        <h2 id="-11">缓存</h2>

        <h3 id="-12">输出文件的文件名</h3>

        <p>在output.filename进行文件名替换，可以使用hash，但是更好的方式是chunkhash，即只有文件改变后，文件名才改变。</p>

        <p>例如</p>

        <pre><code class="js language-js">output:{
            filename:[name].[chunkhash].js
        }
        </code></pre>

        <p>需要注意的是，在使用chunkhash的时候，不能使用热替换插件，用于生产环境较为合理</p>

        <h3 id="-13">提取模板</h3>

        <p>对于一些插件，框架等可以提取出来，这样就可以缓存在浏览器中，不需要每次都向服务器请求</p>

        <p>使用的是CommonsChunkPlugin</p>

        <p>例如</p>

        <pre><code class="js language-js">entry:{
            plugin:['react','vue']
        },
        plugins:[
            new CommonsChunkPlugin({
                name: plugin
            })
        ]
        </code></pre>

        <h3 id="-14">模块标识符</h3>

        <p>在添加或者删除一个文件后，所有chunk的name会发生改变，这是因为解析顺序的改变会导致module.id的改变。如果重新缓存提取的公用模块，会很不理想，可以使用两种插件来优化，一个是NameModuesPlugin，将使用模块的路径，而不是数字标识符，但是执行时间会长。另一个是HashedModuleIdsPlugin，推荐用于生产环境</p>

        <h2 id="library">创建library</h2>

        <h3 id="-15">外部化依赖</h3>

        <pre><code class="js language-js">externals:{
            lodash:{
                commonjs:'lodash',
                commonjs2:'lodash',
                amd:'lodash',
                root:'_'
            }
        }
        </code></pre>

        <h3 id="library-1">暴露library</h3>

        <p>为了是library兼容不同的环境，例如CommonJS,AMD,Node.js或者作为一个全局变量，需要使用library属性</p>

        <pre><code class="js language-js">filename:'example-item',
        library:'exampleItem'
        </code></pre>

        <p>另外需引入libraryTarget属性，以适应更多环境</p>

        <ul>
            <li>遍历：全局变量，script标签访问 'var'</li>

            <li>this:this对象访问 'this'</li>

            <li>window:window对象访问 'window'</li>

            <li>UMD 在AMD或CommonJS的require之后访问 'umd'</li>
        </ul>

        <p>如果设置了library但没设置libraryTarget，默认值位var</p>

        <h3 id="packagejson">package.json</h3>

        <p>生成bundle的文件路径</p>

        <pre><code class="json language-json">"main":"dist/example-item"
        </code></pre>

        <p>标准模块</p>

        <pre><code class="json language-json">"module":"src/index.js"
        </code></pre>

        <h2 id="shimming">shimming</h2>

        <h3 id="-16">全局变量</h3>

        <p>使用
            <code>ProvidePlugin</code>
        </p>

        <pre><code class="js language-js">const webpack = require('webpack');
        
        plugins:[
            new webpack.ProvidePlugin({
                $:'jquery',
                jQuery:'jquery',
                window.jQuery:'jquery'
            })
        ]
        </code></pre>
    </div>
</body>

</html>